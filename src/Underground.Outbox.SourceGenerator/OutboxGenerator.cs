using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Underground.Outbox.SourceGenerator;

[Generator]
public sealed class OutboxGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "OutboxDependencyInjection.g.cs",
            SourceText.From(GenerateDIMethod, Encoding.UTF8)));

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var collectedHandlers = classDeclarations.Collect();

        context.RegisterSourceOutput(
            collectedHandlers,
            static (spc, source) => Execute(source, spc));

        // context.RegisterSourceOutput(context.CompilationProvider, static (spc, _) => spc.AddSource("OutboxDependencyInjection.g.cs", GenerateDIMethod));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 };
    }

    private static HandlerClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var baseType in classDeclaration.BaseList!.Types)
        {
            var typeInfo = context.SemanticModel.GetTypeInfo(baseType.Type);
            if (typeInfo.Type is INamedTypeSymbol typeSymbol
            && typeSymbol.IsGenericType
            && typeSymbol.OriginalDefinition.ToDisplayString() == "Underground.Outbox.IOutboxMessageHandler<T>")
            {
                return new HandlerClassInfo(
                    typeSymbol.ContainingNamespace.ToDisplayString(),
                    classDeclaration.Identifier.Text,
                    // typeSymbol.OriginalDefinition.ToDisplayString(),
                    typeSymbol.TypeArguments[0].ToDisplayString()
                );
            }
        }

        return null;
    }

    private static void Execute(ImmutableArray<HandlerClassInfo?> classes, SourceProductionContext context)
    {
        var handlers = classes.Where(c => c is not null).ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Underground.Outbox.Data;");
        sb.AppendLine("using Underground.Outbox.Domain.Dispatchers;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("namespace Underground.Outbox.Domain;");
        sb.AppendLine();
        sb.AppendLine("#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member");
        sb.AppendLine("public class GeneratedDispatcher<TMessage> : IMessageDispatcher<TMessage> where TMessage : class, IMessage");
        sb.AppendLine("{");
        sb.AppendLine("    public async Task ExecuteAsync(IServiceScope scope, TMessage message, CancellationToken cancellationToken)");
        sb.AppendLine("    {");

        sb.AppendLine($"// {handlers.Count}");

        foreach (var classInfo in handlers)
        {
            sb.AppendLine($"        if (message.Type == \"{classInfo?.ClassName}\")");
            sb.AppendLine("        {");
            sb.AppendLine("        }");
            sb.AppendLine();
            //     var model = compilation.GetSemanticModel(classDecl.SyntaxTree);
            //     var classSymbol = model.GetDeclaredSymbol(classDecl);

            //     if (classSymbol is not null)
            //     {
            //         var fullName = classSymbol.ToDisplayString();
            //         sb.AppendLine($"            typeof({fullName}),");
            //     }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine("#pragma warning restore CS1591");

        context.AddSource("GeneratedDispatcher.g.cs", sb.ToString());
    }

    private static readonly string GenerateDIMethod = @"// <auto-generated/>
#nullable enable

using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

using Underground.Outbox.Data;
using Underground.Outbox.Domain;
using Underground.Outbox.Domain.Dispatchers;

namespace Underground.Outbox.Configuration;

/// <summary>
/// Provides extension methods for configuring and setting up Outbox and Inbox services in the dependency injection container.
/// </summary>
public static class ConfigureOutboxServices
{
    /// <summary>
    /// Configures and registers Outbox services in the dependency injection container.
    /// </summary>
    /// <typeparam name=""TContext"">The DbContext type that implements IOutboxDbContext.</typeparam>
    /// <param name=""services"">The service collection to register services with.</param>
    /// <param name=""configuration"">An action to configure the Outbox service settings.</param>
    public static IServiceCollection AddOutboxServices<TContext>(
        this IServiceCollection services,
        Action<OutboxServiceConfiguration> configuration
    ) where TContext : DbContext, IOutboxDbContext
    {
        services.AddScoped<IMessageDispatcher<OutboxMessage>, GeneratedDispatcher<OutboxMessage>>();
        SetupOutboxServices.SetupInternalOutboxServices<TContext>(services, configuration);

        return services;
    }

    /// <summary>
    /// Configures and registers Inbox services in the dependency injection container.
    /// </summary>
    /// <typeparam name=""TContext"">The DbContext type that implements IInboxDbContext.</typeparam>
    /// <param name=""services"">The service collection to register services with.</param>
    /// <param name=""configuration"">An action to configure the Inbox service settings.</param>
    public static IServiceCollection AddInboxServices<TContext>(
        this IServiceCollection services,
        Action<InboxServiceConfiguration> configuration
    ) where TContext : DbContext, IInboxDbContext
    {
        services.AddScoped<IMessageDispatcher<InboxMessage>, GeneratedDispatcher<InboxMessage>>();
        SetupOutboxServices.SetupInternalInboxServices<TContext>(services, configuration);

        return services;
    }
}
";

    // https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/
    // static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    // {
    //     string nameSpace = string.Empty;

    //     // Get the containing syntax node for the type declaration
    //     // (could be a nested type, for example)
    //     SyntaxNode? potentialNamespaceParent = syntax.Parent;

    //     // Keep moving "out" of nested classes etc until we get to a namespace
    //     // or until we run out of parents
    //     while (potentialNamespaceParent != null &&
    //             potentialNamespaceParent is not NamespaceDeclarationSyntax
    //             && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
    //     {
    //         potentialNamespaceParent = potentialNamespaceParent.Parent;
    //     }

    //     // Build up the final namespace by looping until we no longer have a namespace declaration
    //     if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
    //     {
    //         // We have a namespace. Use that as the type
    //         nameSpace = namespaceParent.Name.ToString();

    //         // Keep moving "out" of the namespace declarations until we
    //         // run out of nested namespace declarations
    //         while (true)
    //         {
    //             if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
    //             {
    //                 break;
    //             }

    //             // Add the outer namespace as a prefix to the final namespace
    //             nameSpace = $"{namespaceParent.Name}.{nameSpace}";
    //             namespaceParent = parent;
    //         }
    //     }

    //     // return the final namespace
    //     return nameSpace;
    // }

}
